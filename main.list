ca65 V2.19 - Git b1e1c13d4
Main file   : ./src/main.asm
Current file: ./src/main.asm

000000r 1               .INCLUDE "macros.inc"
000000r 2               ;MACRO LOAD_FILE (FILE LENGTH),(<FILE NAME),(>FILE NAME),(<LOAD LOCATION),(>LOAD LOCATION),(^LOAD LOCATION)
000000r 2               .MACRO LOAD_FILE LENGTH,X_NAME,Y_NAME,X_LOCATION,Y_LOCATION,A_LOCATION
000000r 2               	LDA LENGTH	;LENGTH OF FILE NAME
000000r 2               	LDX X_NAME
000000r 2               	LDY Y_NAME
000000r 2               	JSR $FFBD	;SETNAM A=FILE NAME LENGTH X/Y=POINTER TO FILENAME
000000r 2               	LDA #$02
000000r 2               	LDX #$08
000000r 2               	LDY #$00
000000r 2               	JSR $FFBA	;SETFLS A=LOGICAL NUMBER X=DEVICE NUMBER Y=SECONDARY
000000r 2               	LDX X_LOCATION
000000r 2               	LDY Y_LOCATION
000000r 2               	LDA A_LOCATION	;LOAD FILE INTO A=1 RAM, A=2 VRAM FOR $0:0000, A=3 VRAM FOR $1:0000
000000r 2               	JSR $FFD5	;LOAD FILE FOR LOAD X/Y=LOAD ADDRESS
000000r 2               	LDA #$02
000000r 2               	JSR $FFC3	;CLOSE FILE
000000r 2               .ENDMACRO
000000r 2               
000000r 2               ;MACRO SET_VERA_ADDR X = VERA_L, Y = VERA_M, A = VERA_H
000000r 2               .MACRO SET_VERA_ADDR
000000r 2               	STX $9F20
000000r 2               	STY $9F21
000000r 2               	STA $9F22
000000r 2               .ENDMACRO
000000r 2               
000000r 1               .INCLUDE "x16.inc"
000000r 2               ; X16 ADDRESSES, VALUES, AND MACROS
000000r 2               ; ACCURATE FOR ROM RELEASE R47
000000r 2               
000000r 2               SD_DEVICE   := 8
000000r 2               DISK_DEVICE := SD_DEVICE ; CHANGE IF LOADING FROM IEC DEVICE
000000r 2               
000000r 2               ; ------------------------------------
000000r 2               ; KERNAL VECTORS
000000r 2               ; ------------------------------------
000000r 2               
000000r 2               ; STANDARD VECTORS
000000r 2               CINV    := $0314 ; IRQ INTERRUPT ROUTINE
000000r 2               CBINV   := $0316 ; BRK INSTRUCTION INTERRUPT
000000r 2               NMINV   := $0318 ; NON-MASKABLE INTERRUPT
000000r 2               IOPEN   := $031A ; KERNAL OPEN ROUTINE
000000r 2               ICLOSE  := $031C ; KERNAL CLOSE ROUTINE
000000r 2               iCHKIN  := $031E ; KERNAL CHKIN ROUTINE
000000r 2               ICKOUT  := $0320 ; KERNAL CKOUT ROUTINE
000000r 2               ICLRCH  := $0322 ; KERNAL CLRCHN ROUTINE
000000r 2               IBASIN  := $0324 ; KERNAL CHRIN ROUTINE
000000r 2               IBSOUT  := $0326 ; KERNAL CHROUT ROUTINE
000000r 2               ISTOP   := $0328 ; KERNAL STOP ROUTINE
000000r 2               IGETIN  := $032A ; KERNAL GETIN ROUTINE
000000r 2               ICLALL  := $032C ; KERNAL CLALL ROUTINE
000000r 2               ILOAD   := $0330 ; KERNAL LOAD ROUTINE
000000r 2               ISAVE   := $0332 ; KERNAL SAVE ROUTINE
000000r 2               
000000r 2               ; 65C816 VECTORS
000000r 2               IECOP   := $0334 ; COP INSTRUCTION INTERRUPT ROUTINE (EMULATION MODE)
000000r 2               IEABORT := $0336 ; ABORT ROUTINE (EMULATION MODE)
000000r 2               INIRQ   := $0338 ; IRQ INTERRUPT ROUTINE (NATIVE MODE)
000000r 2               INBRK   := $033A ; BRK INSTRUCTION INTERRUPT ROUTINE (NATIVE MODE)
000000r 2               INNMI   := $033C ; NON-MASKABLE INTERRUPT ROUTINE (NATIVE MODE)
000000r 2               INCOP   := $033E ; COP INSTRUCTION INTERRUPT ROUTINE (NATIVE MODE)
000000r 2               INABORT := $0340 ; ABORT ROUTINE (NATIVE MODE)
000000r 2               
000000r 2               ; FRAMEBUFFER VECTORS
000000r 2               I_FB_INIT                   := $02E4 ; FRAMEBUFFER ENABLE ROUTINE
000000r 2               I_FB_GET_INFO               := $02E6 ; FRAMEBUFFER INFO ROUTINE
000000r 2               I_FB_SET_PALETTE            := $02E8 ; FRAMEBUFFER PALETTE ROUTINE
000000r 2               I_FB_CURSOR_POSITION        := $02EA ; FRAMEBUFFER CURSOR POSITION ROUTINE
000000r 2               I_FB_CURSOR_NEXT_LINE       := $02EC ; FRAMEBUFFER NEXT LINE ROUTINE
000000r 2               I_FB_GET_PIXEL              := $02EE ; FRAMEBUFFER COPY PIXEL ROUTINE
000000r 2               I_FB_GET_PIXELS             := $02F0 ; FRAMEBUFFER COPY PIXELS ROUTINE
000000r 2               I_FB_SET_PIXEL              := $02F2 ; FRAMEBUFFER SET PIXEL ROUTINE
000000r 2               I_FB_SET_PIXELS             := $02F4 ; FRAMEBUFFER SET PIXELS ROUTINE
000000r 2               I_FB_SET_8_PIXELS           := $02F6 ; FRAMEBUFFER SET 8 PIXELS ROUTINE
000000r 2               I_FB_SET_8_PIXELS_OPAQUE    := $02F8 ; FRAMEBUFFER SET 8 OPAQUE PIXELS ROUTINE
000000r 2               I_FB_FILL_PIXELS            := $02FA ; FRAMEBUFFER FILL PIXELS ROUTINE
000000r 2               I_FB_FILTER_PIXELS          := $02FC ; FRAMEPUFFER TRANSFORM PIXELS ROUTINE
000000r 2               I_FB_MOVE_PIXELS            := $02FE ; FRAMEBUFFER MOVE PIXELS ROUTINE
000000r 2               
000000r 2               ; ------------------------------------
000000r 2               ; KERNAL API FUNCTIONS
000000r 2               ; ------------------------------------
000000r 2               
000000r 2               ; PERIPHERAL BUS
000000r 2               ACPTR   := $FFA5 ; READ A BYTE FROM THE PERIPHERAL BUS
000000r 2               MACPTR  := $FF44 ; READ MULTIPLE BYTES FROM THE PERIPHERAL BUS
000000r 2               MCIOUT  := $FEB1 ; WRITE MULTIPLE BYTES TO THE PERIPHERAL BUS
000000r 2               
000000r 2               ; CHANNEL I/O
000000r 2               BSAVE   := $FEBA ; SAVE AN AREA OF MEMORY TO A FILE WITHOUT WRITING AN ADDRESS HEADER
000000r 2               CLOSE   := $FFC3 ; CLOSE A LOGICAL FILE
000000r 2               LOAD    := $FFD5 ; LOAD THE CONTENTS OF A FILE FROM DISK TO MEMORY
000000r 2               OPEN    := $FFC0 ; OPENS A CHANNEL/FILE
000000r 2               SAVE    := $FFD8 ; SAVE AN AREA OF MEMORY TO A FILE
000000r 2               SETFLS  := $FFBA ; SET FILE PARAMETERS
000000r 2               SETNAM  := $FFBD ; SET FILE NAME
000000r 2               
000000r 2               ; MEMORY
000000r 2               MEMORY_FILL         := $FEE4 ; FILL MEMORY REGION WITH A BYTE VALUE
000000r 2               MEMORY_COPY         := $FEE7 ; COPY MEMORY REGION
000000r 2               MEMORY_CRC          := $FEEA ; CALCULATE CRC16 OF MEMORY REGION
000000r 2               MEMORY_DECOMPRESS   := $FEED ; DECOMPRESS LZSA2 BLOCK
000000r 2               FETCH               := $FF74 ; READ A BYTE FROM ANY RAM OR ROM BANK
000000r 2               STASH               := $FF77 ; WRITE A BYTE TO ANY RAM BANK
000000r 2               MEMTOP              := $FF99 ; GET NUMBER OF BANKS AND ADDRESS OF END OF USABLE RAM
000000r 2               
000000r 2               ; CLOCK
000000r 2               CLOCK_SET_DATE_TIME := $FF4D ; SET DATE AND TIME OF THE RTC
000000r 2               CLOCK_GET_DATE_TIME := $FF50 ; GET DATE AND TIME FROM THE RTC
000000r 2               RDTIM               := $FFDE ; READ SYSTEM CLOCK FROM THE VIA
000000r 2               
000000r 2               ; KEYBOARD
000000r 2               KBDBUF_PEEK             := $FEBD ; GET FIRST CHARACTER IN KEYBOARD QUEUE AND QUEUE LENGTH
000000r 2               KBDBUF_GET_MODIFIERS    := $FEC0 ; GET CURRENTLY PRESSED MODIFIER KEYS
000000r 2               KBDBUF_PUT              := $FEC3 ; APPEND A CHARACTER TO THE KEYBOARD QUEUE
000000r 2               KEYMAP                  := $FED2 ; SET OR GET THE CURRENT KEYBOARD LAYOUT
000000r 2               KBD_SCAN                := $FF9F ; READ A KEYCODE PREVIOUSLY FETCHED FROM THE SMC, APPLY KEYMAP LOCALIZATION, AND ADD IT THE THE X16'S BUFFER
000000r 2               
000000r 2               ; MOUSE
000000r 2               MOUSE_CONFIG    := $FF68 ; CONFIGURE THE MOUSE POINTER
000000r 2               MOUSE_SCAN      := $FF71 ; QUERY THE MOUSE AND SAVE ITS STATE
000000r 2               MOUSE_GET       := $FF6B ; GET THE MOUSE STATE
000000r 2               
000000r 2               ; JOYSTICK
000000r 2               JOYSTICK_SCAN   := $FF53 ; QUERY THE JOYSTICKS AND SAVE THEIR STATE
000000r 2               JOYSTICK_GET    := $FF56 ; GET THE STATE OF ONE OF THE JOYSTICKS
000000r 2               
000000r 2               ; I2C
000000r 2               I2C_BATCH_READ  := $FEB4 ; READ BYTES FROM A GIVE I2C DEVICE INTO A RAM LOCATION
000000r 2               I2C_BATCH_WRITE := $FEB7 ; WRITE BYTES TO A GIVEN I2C DEVICE WITH DATA IN RAM
000000r 2               I2C_READ_BYTE   := $FEC6 ; READ A BYTE AT A GIVEN OFFSET FROM A GIVEN I2C DEVICE
000000r 2               I2C_WRITE_BYTE  := $FEC9 ; WRITE A BYTE AT A GIVEN OFFSET TO A GIVEN I2C DEVICE
000000r 2               
000000r 2               ; SPRITES
000000r 2               SPRITE_SET_IMAGE    := $FEF0 ; SET THE IMAGE OF A SPRITE
000000r 2               SPRITE_SET_POSITION := $FEF3 ; SET THE POSITION OF A SPRITE OR HIDE IT
000000r 2               
000000r 2               ; FRAMEBUFFER
000000r 2               FB_INIT                 := $FEF6 ; ENTER GRAPHICS MODE
000000r 2               FB_GET_INFO             := $FEF9 ; RETURN THE RESOLUTION AND COLOR DEPTH
000000r 2               FB_SET_PALETTE          := $FEFC ; SET (PARTS OF) THE PALETTE
000000r 2               FB_CURSOR_POSITION      := $FEFF ; POSITION THE DIRECT-ACCESS CURSOR
000000r 2               FB_CURSOR_NEXT_LINE     := $FF02 ; MOVE THE DIRECT-ACCESS CURSOR TO THE NEXT LINE
000000r 2               FB_GET_PIXEL            := $FF05 ; READ ONE PIXEL, UPDATE CURSOR
000000r 2               FB_GET_PIXELS           := $FF08 ; COPY PIXELS INTO RAM, UPDATE CURSOR
000000r 2               FB_SET_PIXEL            := $FF0B ; SET ONE PIXEL, UPDATE CURSOR
000000r 2               FB_SET_PIXELS           := $FF0E ; COPY PIXELS FROM RAM, UPDATE CURSOR
000000r 2               FB_SET_8_PIXELS         := $FF11 ; SET 8 PIXELS FROM BIT MASK (TRANSPARENT), UPDATE CURSOR
000000r 2               FB_SET_8_PIXELS_OPAQUE  := $FF14 ; SET 8 PIXELS FROM BIT MASK (OPAQUE), UPDATE CURSOR
000000r 2               FB_FILL_PIXELS          := $FF17 ; FILL PIXELS WITH CONSTANT COLOR, UPDATE CURSOR
000000r 2               FB_FILTER_PIXELS        := $FF1A ; APPLY TRANSFORM TO PIXELS, UPDATE CURSOR
000000r 2               FB_MOVE_PIXELS          := $FF1D ; COPY HORIZONTALLY CONSECUTIVE PIXELS TO A DIFFERENT POSITION
000000r 2               
000000r 2               ; GRAPHICS
000000r 2               GRAPH_INIT          := $FF02 ; ACTIVATE FRAMEBUFFER DRIVER, ENTER AND INITIALIZE GRAPHICS MODE
000000r 2               GRAPH_CLEAR         := $FF23 ; CLEAR THE CURRENT WINDOW WITH THE CURRENT BACKGROUND COLOR
000000r 2               GRAPH_SET_WINDOW    := $FF26 ; SET THE CLIPPING REGION
000000r 2               GRAPH_SET_COLORS    := $FF29 ; SET THE THREE COLORS
000000r 2               GRAPH_DRAW_LINE     := $FF2C ; DRAW A LINE USING THE STROKE COLOR
000000r 2               GRAPH_DRAW_RECT     := $FF2F ; DRAW A RECTANGLE
000000r 2               GRAPH_MOVE_RECT     := $FF23 ; COPY A RECTANGLULAR SCREEN AREA TO A DIFFERENT LOCATION
000000r 2               GRAPH_DRAW_OVAL     := $FF35 ; DRAW AN OVAL OR A CIRCLE
000000r 2               GRAPH_DRAW_IMAGE    := $FF38 ; DRAW A RECTANGULAR IMAGE FROM DATA IN MEMORY
000000r 2               GRAPH_SET_FONT      := $FF3B ; SET THE CURRENT FONT
000000r 2               GRAPH_GET_CHAR_SIZE := $FF3E ; GET THE SIZE AND BASELINE OF A CHARACTER, OR INTERPRET A CONTROL CODE
000000r 2               GRAPH_PUT_CHAR      := $FF41 ; PRINT A CHARACTER ONTO THE GRAPHICS SCREEN
000000r 2               
000000r 2               ; CONSOLE
000000r 2               CONSOLE_INIT                := $FEDB ; INITIALIZE CONSOLE MODE
000000r 2               CONSOLE_PUT_CHAR            := $FEDE ; PRINT A CHARACTER TO THE CONSOLE
000000r 2               CONSOLE_PUT_IMAGE           := $FED8 ; DRAW IMAGE AS IF IT WAS A CHARACTER
000000r 2               CONSOLE_GET_CHAR            := $FEE1 ; GET A CHARACTER FROM THE CONSOLE
000000r 2               CONSOLE_SET_PAGING_MESSAGE  := $FED5 ; SET THE PAGING MESSAGE OR DISABLE PAGING
000000r 2               
000000r 2               ; MISC
000000r 2               ENTER_BASIC         := $FF47 ; ENTER BASIC
000000r 2               ENTROPY_GET         := $FECF ; GET 24 RANDOM BITS
000000r 2               MONITOR             := $FECC ; ENTER MACHINE LANGUAGE MONITOR
000000r 2               SCREEN_MODE         := $FF5F ; GET/SET SCREEN MODE
000000r 2               SCREEN_SET_CHARSET  := $FF62 ; ACTIVATE 8x8 TEXT MODE CHARSET
000000r 2               SCREEN              := $FFED ; GET THE TEXT RESOLUTION OF THE SCREEN
000000r 2               
000000r 2               ; EXTENDED API
000000r 2               EXTAPI                  := $FEAB ; EXTENDED API, THE VALUE OF A. DETERMINES WHICH EXTENDED API CALL
000000r 2               ; A-VALUES
000000r 2               CLEAR_STATUS            := $01 ; RESETS THE KERNAL IEC STATUS TO ZERO
000000r 2               GETLFS                  := $02 ; GETTER COUNTERPART TO SETLFS
000000r 2               MOUSE_SPRITE_OFFSET     := $03 ; GET OR SET MOUSE SPRITE PIXEL OFFSET
000000r 2               JOYSTICK_PS2_KEYCODES   := $04 ; GET OR SET JOY0 KEYCODE MAPPINGS
000000r 2               ISO_CURSOR_CHAR         := $05 ; GET OR SET THE ISO MODE CURSOR CHARACTER
000000r 2               PS2KBD_TYPEMATIC        := $06 ; SET THE KEYBOARD REPEAT DELAY AND RATE
000000r 2               PFKEY                   := $07 ; PROGRAM MACROS FOR THE F1-F8 AND THE RUN KEY
000000r 2               PS2DATA_FETCH           := $08 ; POLLS THE SMC FOR PS/2 KEYBOARD AND MOUSE DATA
000000r 2               FS2DATA_RAW             := $09 ; IF THE POST RECENT PS2DATA_FETCH RECEIVED A MOUSE PACKET OR KEYCODE, RETURNS ITS RAW VALUE
000000r 2               CURSOR_BLINK            := $0A ; BLINKS OR UN-BLINKS THE KERNAL EDITOR CURSOR IF APPROPRIATE
000000r 2               LED_UPDATE              := $0B ; ILLUMINATES OR CLEARS THE SMC ACTIVITY LED BASED ON DISK ACTIVITY OR ERROR STATUS
000000r 2               MOUSE_SET_POSITION      := $0C ; MOVES THE MOUSE CURSOR TO A SPECIFIC X/Y LOCATION
000000r 2               SCNSIZ                  := $0D ; DIRECTLY SETS THE KERNAL EDITOR TEXT DIMENSIONS
000000r 2               
000000r 2               ; 65C816 EXTENDED API
000000r 2               EXTAPI16                := $FEA8 ; 65C816 EXTENDED API, THE VALUE OF A. DETERMINES WHICH EXTENDED API CALL
000000r 2               ; A-VALUES
000000r 2               TEST                        := $00 ; USED BY UNIT TESTS FOR JSRFAR
000000r 2               STACK_PUSH                  := $01 ; POINTS THE STACK POINTER TO A NEW STACK
000000r 2               STACK_POP                   := $02 ; POINT THE STACK POINTER TO THE PREVIOUSLY-SAVED STACK
000000r 2               STACK_ENTER_KERNAL_STACK    := $03 ; POINT THE STACK POINTER TO THE PREVIOUSLY-SAVED $01xx STACK, PRESERVING THE CURRENT ONE
000000r 2               STACK_LEAVE_KERNAL_STACK    := $04 ; POINT THE STACK POINTER TO THE PREVIOUSLY-PRESERVED STACK
000000r 2               
000000r 2               ; ------------------------------------
000000r 2               ; I/O REGISTERS
000000r 2               ; ------------------------------------
000000r 2               
000000r 2               ; VERA REGISTERS
000000r 2               VERA_L			= $9F20
000000r 2               VERA_M			= $9F21
000000r 2               VERA_H			= $9F22
000000r 2               VERA_DATA0		= $9F23
000000r 2               VERA_DATA1      = $9F24
000000r 2               VERA_CTRL       = $9F25
000000r 2               VERA_IEN 		= $9F26
000000r 2               VERA_ISR 		= $9F27
000000r 2               VIDEO_CONFIG	= $9F29 ; (DCSEL = 0)
000000r 2               L0_CONFIG 		= $9F2D
000000r 2               L0_MAPBASE		= $9F2E
000000r 2               L0_TILEBASE		= $9F2F
000000r 2               L0_HSCROLL_L	= $9F30
000000r 2               L0_HSCROLL_H	= $9F31
000000r 2               L0_VSCROLL_L	= $9F32
000000r 2               L0_VSCROLL_H	= $9F33
000000r 2               L1_CONFIG 		= $9F34
000000r 2               L1_MAPBASE 		= $9F35
000000r 2               L1_TILEBASE		= $9F36
000000r 2               L1_HSCROLL_L	= $9F37
000000r 2               L1_HSCROLL_H	= $9F38
000000r 2               L1_VSCROLL_L	= $9F39
000000r 2               L1_VSCROLL_H	= $9F3A
000000r 2               
000000r 2               
000000r 1               .SEGMENT "LOADADDR"
000000r 1  01 08        	.WORD $0801
000002r 1               .SEGMENT "BASICSTUB"
000000r 1  rr rr        	.WORD START-2
000002r 1  00 00 9E     	.BYTE $00,$00,$9E
000005r 1  32 30 36 31  	.BYTE "2061"
000009r 1  00 00 00     	.BYTE $00,$00,$00
00000Cr 1               .SEGMENT "STARTUP"
000000r 1               START:
000000r 1  4C rr rr     	JMP MAIN
000003r 1               .SEGMENT "CODE"
000000r 1               
000000r 1               MAIN:
000000r 1  20 rr rr     	JSR SETUP_VERA
000003r 1  20 rr rr     	JSR LOAD_GRAPHICS
000006r 1  60           	RTS
000007r 1               SETUP_VERA:
000007r 1  A9 71        	LDA #%01110001	;ENABLE SPRITES, LAYER_0, LAYER_1, AND SET TO VGA MODE
000009r 1  8D 29 9F     	STA VIDEO_CONFIG
00000Cr 1  A9 62        	LDA #%01100010	;MAP HEIGHT/WIDTH 128X64 WITH 16 COLORS
00000Er 1  8D 2D 9F     	STA L0_CONFIG
000011r 1  8D 34 9F     	STA L1_CONFIG
000014r 1  A9 00        	LDA #$00		;MAP 0 STORED AT $0:0000
000016r 1  8D 2E 9F     	STA L0_MAPBASE
000019r 1  A9 20        	LDA #$20		;MAP 1 STORED AT $0:4000
00001Br 1  8D 35 9F     	STA L1_MAPBASE
00001Er 1  A9 43        	LDA #%01000011	;TILES STORED AT $1:0000
000020r 1  8D 2F 9F     	STA L0_TILEBASE
000023r 1  8D 36 9F     	STA L1_TILEBASE
000026r 1  A9 05        	LDA #%00000101	;ENABLE VSYNC AND SPRITE COLLISION INTERRUPTS
000028r 1  8D 26 9F     	STA VERA_IEN
00002Br 1  A9 40        	LDA #64			;SCALES THE SCREEN SIZE
00002Dr 1  8D 2A 9F     	STA $9F2A
000030r 1  8D 2B 9F     	STA $9F2B
000033r 1  60           	RTS
000034r 1  4D 41 50 30  MAP_0_FILE:	.BYTE "map0.bin"
000038r 1  2E 42 49 4E  
00003Cr 1  4D 41 50 31  MAP_1_FILE:	.BYTE "map1.bin"
000040r 1  2E 42 49 4E  
000044r 1  54 49 4C 45  TILE_FILE:	.BYTE "tiles.bin"
000048r 1  53 2E 42 49  
00004Cr 1  4E           
00004Dr 1  53 50 52 49  SPRITE_FILE:.BYTE "sprite0.bin"
000051r 1  54 45 30 2E  
000055r 1  42 49 4E     
000058r 1  50 41 4C 2E  PALLETE_FILE:.BYTE "pal.bin"
00005Cr 1  42 49 4E     
00005Fr 1               LOAD_GRAPHICS:
00005Fr 1               	;MACRO LOAD_FILE (FILE LENGTH),(<FILE NAME),(>FILE NAME),(<LOAD LOCATION),(>LOAD LOCATION),(^LOAD LOCATION)
00005Fr 1  A9 08 A2 rr  	LOAD_FILE #8,#<MAP_0_FILE,#>MAP_0_FILE,#$00,#$00,#$02			;LOAD MAP 0 TO $0:0000
000063r 1  A0 rr 20 BD  
000067r 1  FF A9 02 A2  
00007Fr 1  A9 08 A2 rr  	LOAD_FILE #8,#<MAP_1_FILE,#>MAP_1_FILE,#$00,#$40,#$02			;LOAD MAP 1 TO $0:4000
000083r 1  A0 rr 20 BD  
000087r 1  FF A9 02 A2  
00009Fr 1  A9 09 A2 rr  	LOAD_FILE #9,#<TILE_FILE,#>TILE_FILE,#$00,#$80,#$02			;LOAD THE TILESET TO $0:8000
0000A3r 1  A0 rr 20 BD  
0000A7r 1  FF A9 02 A2  
0000BFr 1  A9 0B A2 rr  	LOAD_FILE #11,#<SPRITE_FILE,#>SPRITE_FILE,#$00,#$00,#$03	;LOAD SPRITES TO $1:0000
0000C3r 1  A0 rr 20 BD  
0000C7r 1  FF A9 02 A2  
0000DFr 1  A9 07 A2 rr  	LOAD_FILE #7,#<PALLETE_FILE,#>PALLETE_FILE,#$00,#$FA,#$03	;LOAD THE PALLETE TO $1:FA00
0000E3r 1  A0 rr 20 BD  
0000E7r 1  FF A9 02 A2  
0000FFr 1  60           	RTS
000100r 1  00 00        DEFAULT_IRQ: .ADDR 0
000102r 1               IRQ_HANDLING:
000102r 1               	INIT_IRQ:
000102r 1  AD 14 03     		LDA CINV
000105r 1  8D rr rr     		STA DEFAULT_IRQ
000108r 1  AD 15 03     		LDA CINV+1
00010Br 1  8D rr rr     		STA DEFAULT_IRQ+1
00010Er 1  78           		SEI
00010Fr 1  A9 rr        		LDA #<CUSTOM_IRQ
000111r 1  8D 14 03     		STA CINV
000114r 1  A9 rr        		LDA #>CUSTOM_IRQ
000116r 1  8D 15 03     		STA CINV+1
000119r 1  58           		CLI
00011Ar 1  60           		RTS
00011Br 1               	CUSTOM_IRQ:
00011Br 1  20 rr rr     		JSR VSYNC_IRQ
00011Er 1  20 rr rr     		JSR COLLISION_IRQ
000121r 1  6C rr rr     		JMP (DEFAULT_IRQ)
000124r 1               	VSYNC_IRQ:
000124r 1  AD 27 9F     		LDA VERA_ISR
000127r 1  29 01        		AND #$01
000129r 1  D0 01        		BNE UPDATE_SCREEN
00012Br 1  60           		RTS
00012Cr 1               	UPDATE_SCREEN:
00012Cr 1  20 6B FF     		JSR MOUSE_GET
00012Fr 1  60           		RTS
000130r 1               	COLLISION_IRQ:
000130r 1  29 04        		AND #$04
000132r 1  D0 01        		BNE SPRITE_COLLISION
000134r 1  60           		RTS
000135r 1               	SPRITE_COLLISION:
000135r 1  60           		RTS
000135r 1               
